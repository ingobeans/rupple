use std::{
    io::{stdin, stdout, Write},
    path::PathBuf,
    process::Command,
};

use crossterm::{
    execute, queue,
    style::{ResetColor, SetForegroundColor},
};
use rand::{rng, Rng};

const BASE_CONTENTS: &str = "#![allow(warnings)]
// autogenerated rupple file
use std::fmt::Debug;
fn rupple() -> Option<Box<dyn Debug>> {
// user input
}

fn main() {
    let result = rupple();
    if let Some(result) = result {
        // print result (with blue color ANSI escape code prefixed)
        println!(\"\x1B[34m{:?}\", result);
    }
}
";

const HELP: &str = "/help - prints help
/clear - clears repl
/exit - quits repl
/debug - prints stored repl data";

fn get_leading_whitespace(text: &str) -> String {
    let mut buf = String::new();
    for char in text.chars() {
        if char.is_whitespace() {
            buf.push(char);
        } else {
            break;
        }
    }
    buf
}

/// Formats input code with boilerplate base contents
fn format(mut input: String) -> String {
    if !input.trim().ends_with(";") {
        let mut lines: Vec<String> = input.split(";").map(|f| f.to_string()).collect();
        let last = lines.last_mut().unwrap();
        *last = format!(
            "{}Some(Box::new({}))",
            get_leading_whitespace(last),
            last.trim()
        );
        input = lines.join(";");
    } else {
        input += "\nNone";
    }

    BASE_CONTENTS.replace("// user input", &input)
}

/// Returns success
fn run(
    mut input: String,
    code_path: &PathBuf,
    exe_path: &PathBuf,
    modified: bool,
    with_output: bool,
) -> bool {
    if !with_output {
        input += ";"
    }
    // write file
    let formatted_file_contents = format(input.clone());
    std::fs::write(code_path, formatted_file_contents).unwrap();

    // compile new code (only if code has been modified, or no exe exists)
    if modified || !std::fs::exists(exe_path).unwrap_or(false) {
        // compile
        let compile_process = Command::new("rustc")
            .arg(code_path)
            .arg("-o")
            .arg(exe_path)
            .arg("--color=always")
            .output()
            .unwrap();

        if !compile_process.status.success() {
            if with_output {
                // retry compiling, without output
                return run(input, code_path, exe_path, modified, false);
            }

            stdout().lock().write_all(&compile_process.stderr).unwrap();
            return false;
        }
    }

    // run
    Command::new(exe_path)
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success()
}

/// Generate unique rupple id for temp dir,
/// formatted like "rupple-XXXXX" where "XXXXX" are random characters from the alphabet
fn generate_rupple_id() -> String {
    let mut id = String::from("rupple-");
    let mut rng = rng();

    for _ in 0..5 {
        id += &(rng.random_range(97_u8..122_u8) as char).to_string()
    }
    id
}

/// Finds first occurence of a character, right to left, and returns index of byte
fn string_index_of_char_reverse(text: &str, target: &str) -> Option<usize> {
    let text_len = text.len();
    for inverted_index in 0..text_len {
        let index = text_len - inverted_index - 1;
        let char = &text[index..index + 1];

        if char == target {
            return Some(text_len - inverted_index - 1);
        }
    }
    None
}

fn main() {
    let temp_dir = std::env::temp_dir().join(generate_rupple_id());
    std::fs::create_dir(&temp_dir).expect("couldn't create temp dir :<");

    let code_path = temp_dir.join("main.rs");
    // we use .exe for all OSes, since for windows it is required, and for linux file extension doesn't matter
    // so its fine
    let exe_path = temp_dir.join("main.exe");

    let mut stdout = stdout();

    queue!(stdout, SetForegroundColor(crossterm::style::Color::Green)).unwrap();
    println!("[rupple {}]", env!("CARGO_PKG_VERSION"));

    queue!(
        stdout,
        SetForegroundColor(crossterm::style::Color::DarkGrey)
    )
    .unwrap();
    println!("do /help for list of commands, or just start typing code!");

    // make ctrl+c clean up temp dir
    ctrlc::set_handler(move || {
        std::fs::remove_dir_all(&temp_dir).unwrap();
        std::process::exit(0);
    })
    .unwrap();

    let mut current_file_contents = String::new();
    let mut buf = String::new();
    queue!(stdout, SetForegroundColor(crossterm::style::Color::Green)).unwrap();
    print!("> ");
    loop {
        let mut modified_file_contents = current_file_contents.clone();
        execute!(stdout, ResetColor).unwrap();

        stdin().read_line(&mut buf).unwrap();
        let line_input = buf.trim();

        if line_input.ends_with("\\") {
            buf.remove(string_index_of_char_reverse(&buf, "\\").unwrap());
            print!("  ");
            continue;
        }

        if line_input.starts_with("/") {
            match line_input {
                "/help" => {
                    println!("{HELP}")
                }
                "/clear" | "/reset" => {
                    current_file_contents = String::new();
                    std::fs::remove_file(&exe_path).unwrap();
                }
                "/exit" | "/quit" => {
                    return;
                }
                "/debug" => {
                    println!("{}", current_file_contents);
                }
                _ => {
                    println!("unknown command, do /help for list")
                }
            }
        } else {
            if !modified_file_contents.is_empty() && !modified_file_contents.trim().ends_with(";") {
                modified_file_contents += ";\n";
            }
            modified_file_contents += line_input;
            if line_input.ends_with(";") {
                modified_file_contents += "\n";
            }

            let success = run(
                modified_file_contents.clone(),
                &code_path,
                &exe_path,
                !line_input.is_empty(),
                true,
            );
            queue!(stdout, ResetColor).unwrap();

            if success {
                // only save changes if it compiled successfully
                current_file_contents = modified_file_contents;
            }
        }

        buf = String::new();
        queue!(stdout, SetForegroundColor(crossterm::style::Color::Green)).unwrap();
        print!("> ");
    }
}
